<div style="position: relative;"><a href="https://github.com/bonitasoft/bonita-doc/edit/7.7/md/handling-documents.md"><img style="position: absolute; top: -1px; right: -40px; border: 0; z-index=-100;" src="https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"></a></div>
<h1>Manage documents with code examples using Java APIs</h1>
<p>Code examples that illustrate how the Bonita Engine Java APIs let you create, add a new version and attach documents to a Bonita process.</p>
<h2>More information</h2>
<p>You might want to consult the <a href="bonita/7.7/documents" ng-click="contentCtrl.goTo($event, 'documents')">document documentation</a> first.</p>
<p>A document is treated in a similar way to a variable in Bonita Engine database. It is defined in Bonita Studio or programmatically, and is stored in the Bonita Engine database. Inside a process instance, a document is a byte stream.</p>
<p>A document is treated in a similar way to a variable in Bonita Engine database. It is defined in Bonita Studio or programmatically, and is stored in the Bonita Engine database.</p>
<h2>Set or update the value of a document in a process operation using a script</h2>
<p>In a process operation, you might want to set / update the value of a document data using a groovy script instead of simply use a contract input.<br>
The script should return a <em>DocumentValue</em> .<br>
<strong>N.B</strong>: <em>All the following exemples deal with single document data. For multiple document data, just adapt the scripts to return a list  of DocumentInput instead of a document input.</em></p>
<h4>Create a new document</h4>
<p>The following groovy scripts create a new document from an existing contract input / url / file.</p>
<pre><code class="language-groovy">import java.nio.file.Files

import org.bonitasoft.engine.bpm.contract.FileInputValue
import org.bonitasoft.engine.bpm.document.DocumentValue

// From a contractInput
def DocumentValue createNewDocument(FileInputValue fileFromContract) {
    new DocumentValue(fileFromContract.content, fileFromContract.contentType, fileFromContract.fileName)
}

// From an url
def DocumentValue createNewDocument(String url) {
    new DocumentValue(url);
}

// From an existing file on the fileSystem
def DocumentValue createNewDocument(File file) throws IOException {
    def mimeType = Files.probeContentType(file.toPath())
    new DocumentValue(file.bytes, mimeType, file.name)
}
</code></pre>
<h4>Update the value of an existing document if a new content is provided</h4>
<p>This following script is a way to address the use case of an optional update of the value of a document:<br>
A user might want to change the value of a document, or not. If a new document is uploaded then the value of the data must be updated, if not then the data should be left unchanged.</p>
<pre><code class="language-groovy">import java.nio.file.Files

import org.bonitasoft.engine.bpm.contract.FileInputValue
import org.bonitasoft.engine.bpm.document.DocumentValue

// From a contractInput
def DocumentValue optionalUpdateDocument(long documentId, FileInputValue fileFromContract) {
    return fileFromContract 
        ? new DocumentValue(documentId, fileFromContract.content, fileFromContract.contentType, fileFromContract.fileName)
        : new DocumentValue(documentId)
}

// From an url
def DocumentValue optionalUpdateDocument(long documentId, String url) {
    return url
        ? new DocumentValue(documentId, url)
        : new DocumentValue(documentId)
}

// From an existing file on the fileSystem
def DocumentValue optionalUpdateDocument(long documentId, File file) throws IOException {
    return file
        ? new DocumentValue(documentId, file.bytes, Files.probeContentType(file.toPath()), file.name)
        : new DocumentValue(documentId)
}
</code></pre>
<h2>Create a case with documents</h2>
<p>The following method, <code>createCaseWithDocument</code>, creates a case and attaches documents to it.</p>
<pre><code class="language-groovy">import java.nio.file.Files

import org.bonitasoft.engine.bpm.document.DocumentValue
import org.bonitasoft.engine.exception.BonitaException
import org.bonitasoft.engine.expression.ExpressionBuilder
import org.bonitasoft.engine.operation.OperationBuilder

import com.bonitasoft.engine.api.ProcessAPI

/**
 * In this example, `documents` is a map which link a document data (key) to a file (value)
 * This map will be converted to operations to set document data with DocumentValue
 * We assume in this example that all documents are initialized with Files (i.e contents), it could be URLs! 
 */
def createCaseWithDocument(String processDefinitionName,
        String processVersion,
        Map&lt;String, File&gt; documents,
        ProcessAPI processAPI) throws BonitaException {

    def processDefinitionId = processAPI.getProcessDefinitionId(processDefinitionName, processVersion)
    def operations = []
    def listExpressionsContext = [:]

    // ----- create setDocument operations -----
    documents.keySet().each { documentName -&gt;
        def file = documents.get(documentName)
        def mimeType = Files.probeContentType(file.toPath())
        def documentValue = new DocumentValue(file.bytes, mimeType, file.name)
        def expressionName = documentName + &quot;Reference&quot;
        def expression = new ExpressionBuilder().createInputExpression(expressionName, DocumentValue.class.getName())
        def operation = new OperationBuilder().createSetDocument(documentName, expression)
        operations.add(operation)
        listExpressionsContext.put(expressionName, documentValue)
    }

    // ----- start process instance -----
    processAPI.startProcess(processDefinitionId, operations, listExpressionsContext);
}
</code></pre>
<h2>Attach a document to a case</h2>
<p>To attach a first version of a document data to a case, use the <code>attachDocument</code> method of the process API.<br>
To attach a new version of a document data to a case, use the <code>attachDocumentNewDocumentVersion</code> method of the process API.</p>
<pre><code class="language-groovy">import java.nio.file.Files

import com.bonitasoft.engine.api.ProcessAPI

// Set the first value of the document `documentName` with the file `document`
// throw an exception if `documentName` has already a value
def attachDocumentToCase(ProcessAPI processAPI, long processInstanceId, String documentName, File document) {
    def mimeType = Files.probeContentType(document.toPath())
    processAPI.attachDocument(processInstanceId, documentName, document.name, mimeType, document.bytes)
}

// Update the value of the document `documentName` with the file `document`
// throw an exception if `documentName` doesn't already have a value
def attachNewDocumentVersionToCase(ProcessAPI processAPI, long processInstanceId, String documentName, File document) {
    def mimeType = Files.probeContentType(document.toPath())
    processAPI.attachNewDocumentVersion(processInstanceId, documentName, document.name, mimeType, document.bytes)
}
</code></pre>
<h2>Delete documents of archived cases based on archive date</h2>
<p>The use case is to delete the documents of archived cases older than a certain date.
<code>searchArchivedDocumentsOlderThanArchivedDate</code> look for archived documents
<code>deleteArchivedDocumentsOlderThan</code> delete the content of the document</p>
<p><strong>Warning:</strong> Althought the document binary will be deleted there will still be records in the database. No methods are provided to completely get rid of the document from the database</p>
<pre><code class="language-groovy">
//Search for documents of archived cases with archived date older than &quot;archivedDate&quot;
def SearchResult searchArchivedDocumentsOlderThanArchivedDate(ProcessAPI processAPI, long archivedDate, int startIndex, int maxResults){
	processAPI.searchArchivedDocuments(new SearchOptionsBuilder(startIndex, maxResults).with { 
			lessOrEquals(ArchivedDocumentsSearchDescriptor.ARCHIVE_DATE, archivedDate)
			done()
		 })
}

//Delete archived documents older than archivedDate
def deleteArchivedDocumentsOlderThan(ProcessAPI processAPI, long archivedDate) {
	int startIndex = 0;
	int maxResults = 100
	def searchResult = searchArchivedDocumentsOlderThanArchivedDate(processAPI, archivedDate, startIndex, maxResults)
	while(searchResult.count &gt; 0){
		searchResult.result.each { archivedDocument -&gt;
			processAPI.deleteContentOfArchivedDocument(archivedDocument.contentStorageId.toLong());
		}
		startIndex += maxResults
		searchResult = searchArchivedDocumentsOlderThanArchivedDate(processAPI, archivedDate, startIndex, maxResults)
	}
}

//Then just call the method with desired archivedDate
deleteArchivedDocumentsOlderThan(processAPI, archivedDate);

</code></pre>
<!-- Generated on Wed Dec 04 2019 13:25:31 GMT+0100 (Paris, Madrid) -->