<div style="position: relative;"><a href="https://github.com/bonitasoft/bonita-doc/edit/7.10/md/groovy-in-bonita.md"><img style="position: absolute; top: -1px; right: -40px; border: 0; z-index=-100;" src="https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"></a></div>
<h1>Groovy script language in Bonita</h1>
<p>In Bonita, it is a prerequisite to be comfortable with Java when implementing advanced behaviors in your processes, the below article aims at helping with Groovy, the scripting language used by Bonita.
Groovy has been chosen as the scripting language because it is :</p>
<ul>
<li>Concise, readable and have an expressive syntax, easy to learn for Java developers</li>
<li>Seamlessly and transparently integrates and interoperates with Java and any third-party libraries</li>
</ul>
<h2>From Java to Groovy</h2>
<p>For a complete description, please have a look at the reference documentation <a href="http://groovy-lang.org/differences.html">here</a>.</p>
<h3>Strings</h3>
<p>Text literals are represented in the form of chain of characters called strings. Groovy lets you instantiate <em>java.lang.String</em> objects, as well as GStrings (<em>groovy.lang.GString</em>) which are also called interpolated strings in other programming languages.</p>
<ul>
<li>Single quoted strings are a series of characters surrounded by single quotes:</li>
</ul>
<pre><code class="language-groovy">'a single quoted string'
</code></pre>
<ul>
<li>Triple single quoted strings are a series of characters surrounded by triplets of single quotes and are multiline:</li>
</ul>
<pre><code class="language-groovy">def aMultilineString = '''line one
line two
line three'''
</code></pre>
<ul>
<li>Double quoted strings are a series of characters surrounded by double quotes:</li>
</ul>
<pre><code class="language-groovy">&quot;a double quoted string&quot;
</code></pre>
<div class="alert alert-warning" role="alert">
<p>Double quoted strings are plain <em>java.lang.String</em> if there's no interpolated expression, but are <em>groovy.lang.GString</em> instances if interpolation is present.</p>
</div>
<ul>
<li>String interpolation</li>
</ul>
<p>Any Groovy expression can be interpolated in all string literals, apart from single and triple single quoted strings. Interpolation is the act of replacing a placeholder in the string with its value upon evaluation of the string. The placeholder expressions are surrounded by <code>${}</code> or prefixed with <code>$</code> for dotted expressions. The expression value inside the placeholder is evaluated to its string representation when the GString is passed to a method taking a String as argument by calling <code>toString()</code> on that expression.</p>
<p>Here, we have a string with a placeholder referencing a local variable:</p>
<pre><code class="language-groovy">def name = 'Romain' // a plain string
def greeting = &quot;Hello ${name}&quot;

assert greeting.toString() == 'Hello Romain'
</code></pre>
<p>In addition to <code>${}</code> placeholders, we can also use a lone <code>$</code> sign prefixing a dotted expression:</p>
<pre><code class="language-groovy">def person = [name: 'Romain', age: 34]
assert &quot;$person.name is $person.age years old&quot; == 'Romain is 34 years old'
</code></pre>
<p>But only dotted expressions of the form <code>a.b</code>, <code>a.b.c</code>, etc, are valid, but expressions that would contain parentheses like method calls, curly braces for closures, or arithmetic operators would be invalid.</p>
<p>More about Strings in Groovy <a href="http://docs.groovy-lang.org/docs/groovy-2.4.16/html/documentation/#all-strings">here</a>.</p>
<h3>Lambdas &amp; Closures</h3>
<p>Java 8 supports lambdas and method references:</p>
<pre><code class="language-java">Runnable run = () -&gt; System.out.println(&quot;Run&quot;);
list.forEach(System.out::println);
</code></pre>
<p>Java 8 lambdas can be more or less considered as anonymous inner classes. Groovy doesn't support that syntax, but has closures instead:</p>
<pre><code class="language-groovy">Runnable run = { println 'run' }
list.each { println it } // or list.each(this.&amp;println)
</code></pre>
<p>Closures are heavily used when processing collections:</p>
<pre><code class="language-groovy">def list = ['Daffy', 'Bugs', 'Elmer', 'Tweety', 'Silvester', 'Yosemite']
assert 'Bugs' == list.find { it == 'Bugs' }
assert ['Daffy', 'Bugs', 'Elmer'] == list.findAll { it.size() &lt; 6 }
assert list.any { it =~ /a/ }
assert list.every { it.size() &gt; 3 }
 
def map = [name: 'Messages from mrhaki', url: 'http://mrhaki.blogspot.com', blog: true]
def found = map.find { key, value -&gt; key == 'name' }
assert found.key == 'name' &amp;&amp; found.value == 'Messages from mrhaki'
found = map.find { it.value =~ /mrhaki/ }
assert found.key == 'name' &amp;&amp; found.value == 'Messages from mrhaki'
assert [name: 'Messages from mrhaki', url: 'http://mrhaki.blogspot.com'] == map.findAll { key, value -&gt; value =~ /mrhaki/ }
assert map.any { entry -&gt; entry.value }
assert map.every { key, value -&gt; key.size() &gt;= 3 }
</code></pre>
<p>More about Closures in Groovy <a href="http://docs.groovy-lang.org/docs/groovy-2.4.16/html/documentation/#_closures">here</a>.</p>
<h3>Operators</h3>
<ul>
<li>Identity operator</li>
</ul>
<p>In Groovy, using <code>==</code> to test equality is different from using the same operator in Java. In Groovy, it is calling equals. If you want to compare reference equality, you should use is like in the following example:</p>
<pre><code class="language-groovy">def list1 = ['Groovy 1.8','Groovy 2.0','Groovy 2.3'] // Create a list of strings   
def list2 = ['Groovy 1.8','Groovy 2.0','Groovy 2.3'] // Create another list of strings containing the same elements       
assert list1 == list2 // using ==, we test object equality                                 
assert !list1.is(list2) //	but using 'is', we can check that references are distinct
</code></pre>
<ul>
<li>Safe navigation operator <code>?.</code> to Avoid NullPointerException:</li>
</ul>
<p>Suppose we have a simple model like this:</p>
<pre><code class="language-groovy">class Company {
    Address address
    String name
}
 
class Address {
    Street street
    String postalCode
    String city
}
 
class Street {
    String name
    String number
    String additionalInfo
}
</code></pre>
<p>We want to display the street name, but we don't know if all object instances are available. To avoid a NullPointerException we write the following code:</p>
<pre><code class="language-groovy">// company can be null.
if (company != null &amp;&amp; company.getAddress() != null &amp;&amp; company.getAddress().getStreet() != null) {
    println company.address.street.name
}
</code></pre>
<p>Groovy adds the safe navigation operator to shorten all this to:</p>
<pre><code class="language-groovy">// company can be null.
println company?.address?.street?.name
</code></pre>
<ul>
<li>The Elvis operator <code>:?</code> to shorten ternary expression</li>
</ul>
<pre><code class="language-groovy">def sampleText
 
// Normal ternary operator.
def ternaryOutput = (sampleText != null) ? sampleText : 'Hello Groovy!'
 
// The Elvis operator in action. We must read: 'If sampleText is not null assign
// sampleText to elvisOuput, otherwise assign 'Viva Las Vegas!' to elvisOutput.
def elvisOutput = sampleText ?: 'Viva Las Vegas!'
</code></pre>
<p>More about Operators in Groovy <a href="http://docs.groovy-lang.org/docs/groovy-2.4.16/html/documentation/#groovy-operators">here</a>.</p>
<h3>Groovy truth</h3>
<p>Groovy decides whether an expression is true or false by applying the rules given below.</p>
<ul>
<li>Boolean expressions : True if the corresponding Boolean value is <code>true</code>.</li>
<li>Collections and Arrays: Non-empty Collections and arrays are true.</li>
<li>Matchers: True if the Matcher has at least one match.</li>
<li>Maps: Non-empty Maps are evaluated to true.</li>
<li>Strings: Non-empty Strings, GStrings and CharSequences are coerced to true.</li>
<li>Numbers: Non-zero numbers are true.</li>
<li>Object References: Non-null object references are coerced to true.</li>
</ul>
<p>More about Groovy Truth <a href="http://groovy-lang.org/semantics.html#Groovy-Truth">here</a>.</p>
<h2>Bonita use cases with Groovy</h2>
<p>In the below examples, the following BDM will be used</p>
<p><code>*</code> for mandatory fields</p>
<pre><code class="language-groovy">Comment {
    String content*
    AppUser createdBy* //Aggregation
    DateTime creationDate*
    AppUser lastEditedBy* //Aggregation
}

AppUser {
    String firstName*
    String lastName*
    Address address //Composition
}

Address {
    Street street* //Composition
    String postalCode*
    String city*
}
 
Street {
    String name*
    String number*
    String additionalInfo
}
</code></pre>
<h3>Instantiate a Business Data</h3>
<h4>Using the generated DAO</h4>
<p>By default a <code>newInstance</code> factory method is generated in the object DAO.<br>
This method has as many parameters as mandatory fields for this object.</p>
<pre><code class="language-groovy">appUserDAO.newInstance('Jane','Doe') // create a UserApp instance with firstName = 'Jane' and lastName = 'Doe'
</code></pre>
<h4>Using a constructor with named arguments</h4>
<pre><code class="language-groovy">new Address(street: new Street(number: '32', name: 'Gustave Eiffel'), postalCode: '38000', city: 'Grenoble')
</code></pre>
<h4>From a map</h4>
<p>Given a complex contract input</p>
<pre><code>userInput COMPLEX
	firstName TEXT
	lastName TEXT
</code></pre>
<p>As a COMPLEX input is stored as Map it is possible to write</p>
<pre><code class="language-groovy">userInput as AppUser 
</code></pre>
<h3>List Business Objects using DAO</h3>
<p>When defining your BDM you can write custom queries in JPQL that can be called using the object DAO.
Some queries are generated by default like: <code>find</code>, <code>findByFirstName</code>, <code>findByLastName</code>...</p>
<p>All object DAO are injected at runtime in Groovy script expression or can be retrieved using <a href="https://documentation.bonitasoft.com/javadoc/api/7.10/org/bonitasoft/engine/api/APIClient.html#getDAO-java.lang.Class-" target="_self">APIClient#getDAO</a></p>
<p>Here is the UserAppDAO interface generated for the UserApp object:</p>
<pre><code class="language-java">public interface AppUserDAO extends BusinessObjectDAO {
    public AppUser findByPersistenceId(Long persistenceId);

    public List&lt;AppUser&gt; findByFirstName(String firstName, int startIndex, int maxResults);

    public List&lt;AppUser&gt; findByLastName(String lastName, int startIndex, int maxResults);

    public List&lt;AppUser&gt; find(int startIndex, int maxResults);

    public Long countForFindByFirstName(String firstName);

    public Long countForFindByLastName(String lastName);

    public Long countForFind();

    public AppUser newInstance(String firstName, String lastName);
}
</code></pre>
<p>So, in a Groovy script, you can access the data like this:</p>
<pre><code class="language-groovy">def users = appUserDAO.find(0, 10) // returns to first tens users ordered by persistenceId
def johnUsers = appUserDAO.findByFirstName('John', 0, 10) // returns to first tens users with firstName == 'John' ordered by persistenceId
</code></pre>
<h3>Update a Business Data</h3>
<p>The example below is the generated code when editing a UserApp address from a contract</p>
<p><code>user</code> is the existing data in the process<br>
<code>userInput</code> is the contract input of the edition task</p>
<pre><code class="language-groovy">if (!userInput?.address) { // As Address is not mandatory it can be null
	return null
}
def addressVar = user.address ?: new com.company.model.Address() // Retrieve the existing address or create a new one
addressVar.street = { //Use a Closure to resolve the street value
	if (!userInput?.address?.street) { // Street is mandatory so it can't be null here, protected by a contract constraint, null-check statement is generated anyway
		return null
	}
	def streetVar = addressVar.street ?: new com.company.model.Street() // Retrieve the existing street or create a new one
	// Assign contract values, note that nullsafe navigators are used even if we know that userInput.address is not null here
	streetVar.name = userInput?.address?.street?.name 
	streetVar.number = userInput?.address?.street?.number
	streetVar.additionalInfo = userInput?.address?.street?.additionalInfo
	return streetVar}() //execute the Closure to assign  the Street value to address
addressVar.postalCode = userInput?.address?.postalCode
addressVar.city = userInput?.address?.city
return addressVar // Return the edited (or new) address
</code></pre>
<p>As it is generated code it has to work in many situation so it is not the most concise code.
Here is another example where it updates the <em>lastEditedBy</em> aggregation relation</p>
<pre><code class="language-groovy">//Retrieve aggregated AppUser using its DAO and persistenceId
def appUserVar = appUserDAO.findByPersistenceId(commentInput?.lastEditedBy?.persistenceId_string?.trim() ? commentInput.lastEditedBy.persistenceId_string.toLong() : null) //commentInput?.lastEditedBy?.persistenceId_string?.trim() checks that the persistenceId_string is not null and not empty after removing all whitspaces
if (!appUserVar) { // no userApp found for the given persistenceId
	if (commentInput?.lastEditedBy?.persistenceId_string?.trim() ? commentInput.lastEditedBy.persistenceId_string.toLong() : null) {
		// Throw an exception to explain that the given persistenceId is invalid
		throw new IllegalArgumentException(&quot;The aggregated reference of type `AppUser` with the persistence id &quot; + commentInput?.lastEditedBy?.persistenceId_string?.trim() ? commentInput.lastEditedBy.persistenceId_string.toLong() : null + &quot; has not been found.&quot;)
	}
	//Just return null when no persistenceId is given, case of a not mandatory relation
	return null
}
return appUserVar //Return the user found for the given persistenceId
</code></pre>
<h3>Search for Tasks instances</h3>
<p>In a Groovy script expression you can access Bonita APIs using the <code>apiAccessor</code> provided variable.</p>
<pre><code class="language-groovy">def user = apiAccessor.identityAPI.getUserByUserName('john.doe')
def johnsTasks = apiAccessor.processAPI
	.searchHumanTaskInstances(new SearchOptionsBuilder(0, 50).with { // using groovy builder 
		filter(HumanTaskInstanceSearchDescriptor.ASSIGNEE_ID, user.id)
		sort(HumanTaskInstanceSearchDescriptor.DUE_DATE, Order.DESC)
		done()
	})
	.result // returns the 50 first opened tasks assigned to john.doe sorted by due date
</code></pre>
<h3>Get CustomUserInfo value for a user</h3>
<p>In a Groovy script expression you can access Bonita APIs using the <code>apiAccessor</code> provided variable.</p>
<pre><code class="language-groovy">def user = apiAccessor.identityAPI.getUserByUserName('john.doe')
def customInfo1Value = apiAccessor.identityAPI
                 .getCustomUserInfo(user.id, 0, 1000)
                 .find { &quot;customInfo1&quot; == it.getDefinition().getName() }
                 ?.getValue()
</code></pre>
<h2>References</h2>
<ul>
<li><a href="http://docs.groovy-lang.org/docs/groovy-2.4.16/html/documentation/">Groovy 2.4.16 official documentation</a></li>
<li><a href="https://mrhaki.blogspot.com/search/label/Groovy%3AGoodness">Groovy Goodness by MrHaki</a></li>
</ul>
<!-- Generated on Tue Dec 10 2019 12:49:52 GMT+0100 (Paris, Madrid) -->