<div style="position: relative;"><img style="position: absolute; top: -1px; right: -40px; border: 0; z-index=-100;" src="bonita/images/7.3/outOfSupport.png" alt="Out of support"></div>
<h1>Shared transactions</h1>
<p>There are three entry points to transactions in the Bonita BPM Engine:</p>
<ul>
<li>API call: one transaction for each call. The transaction is opened automatically by the Engine if it has not been opened externally.</li>
<li>Work units: one transaction per work unit (that inherits TxBonitaWork). A work unit is asynchronous, and is executed as soon as possible when an Execution thread becomes available.</li>
<li>Jobs: when a Scheduler job triggers, it opens a new transaction if it is not itself contained in an existing open transaction.</li>
</ul>
<p>If you are accessing the Engine in Local mode, you also have the option of using shared transactions, which means you can include Engine API calls in a transaction that is managed explicitly by a calling program.
For example, in an application for approving and paying expenses, you could have a single transaction that includes the payment instruction sent to the bank and the process step that informs the user that expenses have been paid. If the bank does not complete the payment, the notification is not sent.</p>
<p>A transaction managed by the caller has the following structure:</p>
<pre><code class="language-java">startTransaction();
try {
   myBusinessLogic1();
   callBonitaBPMEngine();
   myBusinessLogic2();
   commitTransaction();
} catch (Exception e) {
   rollbackTransaction();
}
</code></pre>
<p>The example below shows how to wrap two Engine API calls in the same transaction. Each call updates the value of a variable, and the transaction guarantees that both values are updated or neither value is updated.</p>
<pre><code class="language-java">long procId = processInstance.getId();
try {
   txManager.begin();
   // We want the following 2 calls to be in the same transaction.
   processAPI.updateProcessDataInstance(dataFoo, procId, new Integer(42));
   processAPI.updateProcessDataInstance(dataBar, procId, new Integer(42));
} finally {
   // We explicitly roll back the current transaction
   txManager.rollback();
}

// Start a new transaction to fetch the data values 
//   and ensure their values were not updated.
txManager.begin();
DataInstance processDataInstanceFoo = processAPI.getProcessDataInstance(dataFoo, procId);
DataInstance processDataInstanceBar = processAPI.getProcessDataInstance(dataBar, procId);
if (((Integer) processDataInstanceFoo.getValue()) != 3 &amp;&amp; ((Integer) processDataInstanceBar.getValue()) != 4) {
   System.err.println(&quot;The values for the variables foo and bar should not have been changed.&quot;);
}
txManager.commit();
</code></pre>
<p>It is also possible to manage your own transactions in the server side of the Engine using Commands.
The CommandAPI, which executes some custom code on the server side, enables you to execute code in several transactions if necessary.
To do this, it provides access to the UserTransactionService exposing the following methods:</p>
<ul>
<li><code>registerBonitaSynchronization(BonitaTransactionSynchronization txSync)</code></li>
<li><code>executeInTransaction(Callable&lt;T&gt; callable)</code></li>
</ul>
<p>Two implementation of the executeInTransaction method are provided:</p>
<ul>
<li>Community Edition: basic execution</li>
<li>Subscription Edition: retries, only on certain exceptions (IOException, Row locked, ...)</li>
</ul>
<p>Below are examples of code that can be used in a user Command.</p>
<p>Anonymous class:</p>
<pre><code class="language-java">final long processInstanceId = 1704;
final SProcessInstanceServiceprocessInstanceService = serviceAccessor.getProcessInstanceService();
SProcessInstance pi = userTransactionService.executeInTransaction(new Callable&lt;SProcessInstance&gt;() {
	@Override
	public SProcessInstance call() throws Exception {
		return processInstanceService.getProcessInstance(processInstanceId);
	}
});
</code></pre>
<p>Custom class:</p>
<pre><code class="language-java">class MyCallable implements Callable&lt;SProcessInstance&gt; {
	private final ProcessInstanceService processInstanceService;
	private long processInstanceId;

	MyCallable(ProcessInstanceService processInstanceService) {
		this.processInstanceService = processInstanceService;
	}

	@Override
	public SProcessInstance call() throws Exception {
		return processInstanceService.getProcessInstance(processInstanceId);
	}
	
	public void setProcessInstanceId(long processInstanceId) {this.processInstanceId = processInstanceId;}
}

class MyCommand extends TenantCommand {
	@Override
    public Serializable execute(final Map&lt;String, Serializable&gt; parameters, final TenantServiceAccessor serviceAccessor) {
		SProcessInstanceService processInstanceService = serviceAccessor.getProcessInstanceService();
		MyCallable callable = new MyCallable(processInstanceService);
		SProcessInstance processInstance;
		// ... custom treatment...
		callable.setProcessInstanceId(1704);
		// First transaction:
		processInstance = userTransactionService.executeInTransaction(callable);
		// ... custom treatment...
		callable.setProcessInstanceId(1209);
		// Second transaction:
		processInstance = userTransactionService.executeInTransaction(callable);
		// Of course, MyCallable implementation is stateless, so it is reusable.
    }
}
</code></pre>
<!-- Generated on Tue Jun 19 2018 09:27:08 GMT+0200 (Paris, Madrid (heure d’été)) -->